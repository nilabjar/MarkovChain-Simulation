
#ifndef STATE_SPACE_GENH
#define STATE_SPACE_GENH

#include "Task.h"
#include "State.h"
#include <map>
#include "engine.h"

typedef enum {RM, EDF, LLF, SJF, OTH, DLJ, CON, RND, PVAL, PVALM, MLF, OPT} SCHED_ALGO;

class State_Space_Gen
{
public:

  State_Space_Gen (SCHED_ALGO algo);
  ~State_Space_Gen ();

  void init_states ();

  void generate_states (int num_of_tasks);

  void generate_states_names ();

  int scheduling_states (State* parent);

	int scheduling_event_states (State* parent);

  void schedule_task (State* parent, const char * state, float& p_value);

//  Task_List tasks;

  Task task_1;
  Task task_2;

  State_List old_states;

  State_List new_states;

  State_List::iterator find_next_state (State& state);

  State_List::iterator find_a_state (State& state, State_List& list);

  int print_states ();

  int generate_simulatanoeus_eqn ();
  
	// generate the contranits equation for using with the
	// fmincon
  int generate_con_opt_eqn ();


	// generate the equation to compute deadline misses ...
  int gen_ddln_miss_eqn ();

	// generate the equation to compute deadline mets ...
  void gen_ddln_met_eqn ();

	// generates the equation for cpu utils 
	void gen_cpu_util_eqn ();

	// compute the deadline misses ....
  void compute_ddln_met ();

	void compute_cpu_util ();

  int create_edge (State* parent,
                   State* next_state, 
                   float rate, 
                   Event ev,
                   State_Type type,
                   int var_no);
  
  int solve_simul_eqn ();
  int compute_ddln_miss ();

  void read_p_values ();

  void pval_modify ();

  typedef vector<double> WTS_ARRAY;

  static int start_simulation ();
  static int stop_simulation ();

  int print_result ();

  int other_var_no;

  vector <WTS_ARRAY> ddln_miss;
  vector <WTS_ARRAY> ddln_met;

  map<int, float> state_p_vec;

  double * rate_matrix;
//  vector <double> rate_matrix;
  double* b_vector;
  double* state_probs;

  vector<double> p_vector;

  map<int, int> con_var_nos;

	void not_matlab (){no_matlab_ = true;}

	// creates sparse matrice from rate_matrix
	void create_sparse_matrice ();

	// generates the sparse map containing the 
	// full data 
	void generate_sparse_map ();

	// creates the sparse matrice from the map
	void create_sparse_matrice_from_map ();

private:

  void RM (State* parent, const char * state, float& p_value);
  void LLF (State* parent, const char * state, float& p_value);
  void SJF (State* parent, const char * state, float& p_value);
  void EDF (State* parent, const char * state, float& p_value);
  void DLJ (State* parent, const char * state, float& p_value);
  void RND (State* parent, const char * state, float& p_value);
  void PVAL (State* parent, const char * state, float& p_value);

	void MLF (State* parent, const char * state, float& p_value);
	void OPT (State* parent, const char * state, float& p_value);

  int cur_state_id;

  //matlab engine 
  static Engine *ep;

  SCHED_ALGO algo_;

  int pval_index;

  double ddln_miss_1;
  double ddln_miss_2;

  double ddln_met_1;
  double ddln_met_2;

  long long expt_num;

	// states is which both tasks are idle 
	vector<int> idle_state_ids_;

	//states in which task 1 is idle 
	vector<int> idle_states_t_1_;

	//states in which task 1 is idle 
	vector<int> idle_states_t_2_;

	// total cpu_util_ 
	float cpu_util_;

	//cpu_util_ task 1
	float cpu_util_1_;

	//cpu_util_ task 2
	float cpu_util_2_;

	// contains the ids for each state
	// this is generated by running the CON OPT option
	// and used by other algos. This will ensure a 
	// consistent ids used for each state
	map <int , int> state_ids;

	/// use matlab or not .....
	bool no_matlab_;

	/// maps to generate sparse matrix data ..

	// represents a sparse row
	typedef map<int, int> SP_ROW;

	// represents a sparse matrix
	typedef map<int, SP_ROW> SP_MATRIX;

	// full data ..
	SP_MATRIX	sparse_map_;
};

#endif